1. 3 will be printed out because var makes i have function scope. In the for loop on line 6, prices.length is 3 from the function call on line 19. Therefore to exit the for loop i is 3. That is why at line 12 the output is 3.
2. 150 will be printed out because var makes dicountedPrice have function scope. On line 7, discountedPrice is set to 150 during the third and last iteration of the for loop. For that iteration, prices[i]=300 and discount is 0.5, 300 * (1 - 0.5) = 150. That is why 150 is the output of line 13.
3. 150 will be printed out because var makes finalPrice have function scope. As stated previously on the last iteration of the loop discountedPrice is 150. On line 8 Math.round(discountedPrice * 100)/100 is Math.round(150 * 100)/100=15000/100=150. Therefore 150 would be the output of line 14.
4. [50, 100, 150] would be what is returned. For every iteration of the for loop discounted is 0.5 from the function call. For the first iteration of the loop prices[i] is prices[0] which is 100, that makes discountedPrice 50 which also make finalPrice 50 before the value 50 is pushed into discounted. For the second iteration of the loop prices[i] is prices[1] which is 200, that makes discountedPrice 100 which also make finalPrice 100 before the value 100 is pushed into discounted. For the thrid and final full iteration of the loop prices[i] is prices[2] which is 300, that makes discountedPrice 150 which also make finalPrice 150 before the value 150 is pushed into discounted. That makes discounted = [50, 100, 150] which is the return value.
5. At line 12 Error: i not defined will be printed as the only time i is given a value is inside a previous block. However in that block let gives i block scope which means that instance of i only exisits within that block. Therefore at line 12 i has no value therefore that error will be produced.
6. At line 13 Error: discountedPrice not defined will be printed as the only time discountedPrice is given a value is inside a previous block. However in that block let gives discountedPrice block scope which means that instance of discountedPrice only exisits within that block. Therefore at line 13 discountedPrice has no value therefore that error will be produced.
7. At line 14, 150 will be printed because since finalPrice is initiated with let at the current level it will still have the value from when it was given a value inside of the previous block. On line 7, discountedPrice is set to 150 during the third and last iteration of the for loop. For that iteration, prices[i]=300 and discount is 0.5, 300 * (1 - 0.5) = 150. On line 8 Math.round(discountedPrice * 100)/100 is Math.round(150 * 100)/100=15000/100=150. Therefore 150 would be the output of line 14.
8. [50, 100, 150] would be what is returned. For every iteration of the for loop discounted is 0.5 from the function call. For the first iteration of the loop prices[i] is prices[0] which is 100, that makes discountedPrice 50 which also make finalPrice 50 before the value 50 is pushed into discounted. For the second iteration of the loop prices[i] is prices[1] which is 200, that makes discountedPrice 100 which also make finalPrice 100 before the value 100 is pushed into discounted. For the thrid and final full iteration of the loop prices[i] is prices[2] which is 300, that makes discountedPrice 150 which also make finalPrice 150 before the value 150 is pushed into discounted. That makes discounted = [50, 100, 150] which is the return value.
9. There would have been an error because you can not redefine the value of a const which is attempted on line 7.
10. There would have been an error because you can not redefine the value of a const which is attempted on line 7.
11. There would have been an error because you can not redefine the value of a const which is attempted on line 7.
12. A. student.name accesses the value of the name property of the student object.  
    B. student['Grad Year'] accesses the Grad Year property of the student object.  
    C. student.greeting() calls the greeting function of the student object.  
    D. student['Favorite Teacher'].name accesses the name of the property in the Favorite Teacher property in student.  
    E. student.courseLoad[0] accesses the zero index in the array in the courseLoad property of the student object.  
13. A. '32' will be the output because javascript defaults to contatonation and converts the nunmber into a string and concatonates them.  
    B. 1 will be the output because there is no - operator for strings therefore it converts the string into a number and finds the difference them.  
    C. 3 will be the output because when adding a number to null the default of javascript is to make null 0 therefore it will just be the number.  
    D. '3null' will be the output because when adding a string to null it just turns null into the string 'null' and concatonates them.  
    E. 4 as when adding true to a number true is by default turned into 1 and 1 + 3 is 4.  
    F. 0 as when adding false and null the default of javascript is to turn them both into numbers which would both be 0.  
    G. '3undefined' will be the output as when adding a string to undefined javascript default turns undefined into the string 'undefined' and concatonates them.  
    H. NaN will be the output because when you do subtraction with a string javascript converts them into number, but undefined when converted to a number is still undefined therefore the result is NaN.  
14. A. true as when you compare a string and number it default compares them as numbers and 2 > 1 is true.  
    B. false as when you compare two strings it compares there characters from left to right and 2 has a higher value then 1 therefore '2' < '12' is false.  
    C. true as when you compare a string and a number it defaults to comparing them as numbers and 2 == 2, therefore 2 == '2'.  
    D. false as when you do === it means to do it without type conversion therefore 2 === '2' is false as they are different types.  
    E. false as when you compare a boolean with a number it default changes true to 1 and false to 0, as 1 == 2 is false,  true == 2 is also false.  
    F. true as when you do Boolean(2) you get true as the Boolean of any number besides 0 is true and true === true is true.  
15. == compares to see whether the two objects it are comparing are equivalent using type conversion if needed. === compares to see whether two objects are equivalent without type conversion.
17. [2, 4, 6], the original array is [1, 2, 3], the for loop iterates through each element of the original array. Callback is doSomething which doubles the value its given. In the for loop the double of the original value from the original array is added to the new array. After going through the entire for loop, the new array is [2, 4, 6] which is the return value resulting from modifyArray([1,2,3], doSomething).
19. 
